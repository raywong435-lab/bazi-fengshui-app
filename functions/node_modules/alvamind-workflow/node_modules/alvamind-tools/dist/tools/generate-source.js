#!/usr/bin/env node
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const chalk_1 = __importDefault(require("chalk"));
const glob_1 = __importDefault(require("glob"));
const projectDir = process.cwd();
function generateSourceCodeMarkdown(options) {
    return __awaiter(this, void 0, void 0, function* () {
        const { outputFilename = 'source-code.md', includePatterns = [], excludePatterns = [], removeBlankLines = true, removeComments = true, } = options;
        const projectName = path.basename(projectDir);
        console.log(chalk_1.default.cyan.bold('\nğŸ“ Generating Source Code Doc'));
        console.log(chalk_1.default.dim('=====================================\n'));
        console.log(chalk_1.default.dim(`Current working directory: ${projectDir}`));
        const defaultExcludedPatterns = [
            '**/node_modules/**',
            '**/dist/**',
            '**/.git/**',
            '**/generate-source.ts',
            '**/.zed-settings.json',
            '**/.vscode/settings.json',
            '**/package-lock.json',
            '**/bun.lockb',
            '**/build/**',
            outputFilename,
        ];
        const singleLineCommentRegex = /^\s*\/\/.*$/gm;
        const multiLineCommentRegex = /\/\*[\s\S]*?\*\//g;
        function getMatchingFiles() {
            const allFiles = [];
            // Convert patterns like "*.route.ts" to "**/*.route.ts" to match in all directories
            const processedExcludePatterns = excludePatterns.map((pattern) => pattern.startsWith('*') && !pattern.startsWith('**') ? `**/${pattern}` : pattern);
            if (includePatterns.length > 0) {
                includePatterns.forEach((pattern) => {
                    const matches = glob_1.default.sync(pattern.includes('*') ? pattern : `**/${pattern}`, {
                        cwd: projectDir,
                        ignore: [...defaultExcludedPatterns, ...processedExcludePatterns],
                        nodir: true,
                    });
                    allFiles.push(...matches);
                });
            }
            else {
                const matches = glob_1.default.sync('**/*', {
                    cwd: projectDir,
                    ignore: [...defaultExcludedPatterns, ...processedExcludePatterns],
                    nodir: true,
                });
                allFiles.push(...matches);
            }
            return [...new Set(allFiles)];
        }
        console.log(chalk_1.default.yellow('ğŸ” Scanning...'));
        const matchingFiles = getMatchingFiles();
        const directories = [
            ...new Set(matchingFiles.map((file) => path.dirname(file)).filter((dir) => dir !== '.')),
        ];
        console.log(chalk_1.default.green(`âœ“ Found ${chalk_1.default.bold(matchingFiles.length)} files in ${chalk_1.default.bold(directories.length)} dirs\n`));
        let output = `# Project: ${projectName}\n\n`;
        output += `## ğŸ“ Dir Structure:\n${directories
            .map((dir) => {
            // Get files for this directory
            const dirFiles = matchingFiles.filter((file) => path.dirname(file) === dir);
            // Return directory with its files indented
            return `- ${dir}/\n${dirFiles.map((file) => `  â€¢ ${path.basename(file)}`).join('\n')}`;
        })
            .join('\n')}\n\n`;
        const rootFiles = matchingFiles.filter((file) => path.dirname(file) === '.');
        if (rootFiles.length > 0) {
            output += `- ./\n${rootFiles.map((file) => `  â€¢ ${file}`).join('\n')}\n`;
        }
        output += `## ğŸš« Excludes:\n${[...defaultExcludedPatterns, ...excludePatterns]
            .map((p) => `- ${p}`)
            .join('\n')}\n\n`;
        output += `## ğŸ“ Dir Structure:\n${directories.map((p) => `- ${p}`).join('\n')}\n\n`;
        output += '## ğŸ’» Code:\n====================\n\n';
        let totalLines = 0;
        let processedFiles = 0;
        console.log(chalk_1.default.yellow('ğŸ“‹ Processing...'));
        for (const file of matchingFiles) {
            process.stdout.write(`\r${chalk_1.default.dim(`Processing: ${processedFiles}/${matchingFiles.length} files`)}`);
            output += `// ${file}\n`;
            let content = fs.readFileSync(path.join(projectDir, file), 'utf-8');
            if (removeComments) {
                content = content.replace(multiLineCommentRegex, '');
                content = content.replace(singleLineCommentRegex, '');
            }
            if (removeBlankLines) {
                content = content
                    .split('\n')
                    .filter((line) => line.trim() !== '')
                    .join('\n');
            }
            else {
                content = content.replace(/\n\s*\n\s*\n/g, '\n\n');
            }
            const lines = content.split('\n');
            totalLines += lines.length;
            output += content + '\n\n';
            processedFiles++;
        }
        process.stdout.write('\r' + ' '.repeat(60) + '\r');
        const outputPath = path.join(projectDir, outputFilename);
        console.log(chalk_1.default.dim(`â€¢ Output Path: ${chalk_1.default.cyan(outputPath)}`));
        try {
            fs.writeFileSync(outputPath, output);
            console.log(chalk_1.default.green('\nâœ¨ Doc gen success!'));
            console.log(chalk_1.default.dim('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€'));
            console.log(chalk_1.default.white(`ğŸ“Š Stats:`));
            console.log(chalk_1.default.dim(`â€¢ Output: ${chalk_1.default.cyan(outputFilename)}`));
            console.log(chalk_1.default.dim(`â€¢ Files: ${chalk_1.default.cyan(matchingFiles.length)}`));
            console.log(chalk_1.default.dim(`â€¢ Dirs: ${chalk_1.default.cyan(directories.length)}`));
            console.log(chalk_1.default.dim(`â€¢ LOC: ${chalk_1.default.cyan(totalLines)}`));
            console.log(chalk_1.default.dim(`â€¢ Blank lines: ${chalk_1.default.cyan(removeBlankLines ? 'Removed' : 'Preserved')}`));
            console.log(chalk_1.default.dim(`â€¢ Comments: ${chalk_1.default.cyan(removeComments ? 'Removed' : 'Preserved')}`));
            console.log(chalk_1.default.dim('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n'));
        }
        catch (error) {
            console.error(chalk_1.default.red('\nâŒ Doc gen fail:'));
            console.error(chalk_1.default.dim(error));
            process.exit(1);
        }
    });
}
function parseArgs(args) {
    const options = {
        outputFilename: 'source-code.md',
        includePatterns: [],
        excludePatterns: [],
        removeBlankLines: true,
        removeComments: true,
    };
    try {
        for (let i = 0; i < args.length; i++) {
            const arg = args[i];
            if (arg.startsWith('--output=')) {
                options.outputFilename = arg.split('=')[1];
            }
            else if (arg.startsWith('--include=')) {
                options.includePatterns = arg
                    .split('=')[1]
                    .split(',')
                    .map((p) => p.trim())
                    .filter((p) => p);
            }
            else if (arg.startsWith('--exclude=')) {
                options.excludePatterns = arg
                    .split('=')[1]
                    .split(',')
                    .map((p) => p.trim())
                    .filter((p) => p);
            }
            else if (arg === '--preserve-blank-lines') {
                options.removeBlankLines = false;
            }
            else if (arg === '--preserve-comments') {
                options.removeComments = false;
            }
        }
    }
    catch (error) {
        console.log(chalk_1.default.red('\nâŒ Args error:'));
        console.log(chalk_1.default.dim(error));
        console.log(chalk_1.default.yellow('\nUsage:'));
        console.log(chalk_1.default.dim('generate-source --include=main.test.ts,test.interface.ts --exclude=dist/,build/ --output=docs.md\n'));
        process.exit(1);
    }
    return options;
}
const args = process.argv.slice(2);
if (args.length === 0 || args.includes('--help')) {
    console.log(chalk_1.default.cyan.bold('\nğŸ“˜ Source Doc Gen'));
    console.log(chalk_1.default.dim('====================================='));
    console.log(chalk_1.default.white('\nUsage:'));
    console.log(chalk_1.default.dim('  generate-source [options]'));
    console.log(chalk_1.default.white('\nOptions:'));
    console.log(chalk_1.default.dim('  --include=<paths>         Include paths, comma separated'));
    console.log(chalk_1.default.dim('  --exclude=<paths>         Exclude paths, comma separated'));
    console.log(chalk_1.default.dim('  --output=<filename>       Output file (default: source-code.md)'));
    console.log(chalk_1.default.dim('  --preserve-blank-lines    Keep blank lines'));
    console.log(chalk_1.default.dim('  --preserve-comments       Keep comments'));
    console.log(chalk_1.default.white('\nExamples:'));
    console.log(chalk_1.default.dim('  generate-source --include=src/,scripts/'));
    console.log(chalk_1.default.dim('  generate-source --exclude=tests/,temp/'));
    console.log(chalk_1.default.dim('  generate-source --include=src/ --exclude=src/tests --output=docs.md'));
    console.log(chalk_1.default.dim('  generate-source --include=src/ --preserve-blank-lines --preserve-comments\n'));
    process.exit(0);
}
const options = parseArgs(args);
generateSourceCodeMarkdown(options).catch((err) => {
    console.log(chalk_1.default.red('\nâŒ Doc gen fail:'));
    console.log(chalk_1.default.dim(err));
    process.exit(1);
});
